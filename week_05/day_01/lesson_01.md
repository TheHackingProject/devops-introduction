# Un outil CI/CD, mais pourquoi faire ?

## 1. Historique et contexte
Cher moussaillon, maitriser et déployer son code de manière continue est une preoccupation qui ne datent pas d'hier.
Depuis longtemps les devs ont voulu maitriser ce processus et quand je dis longtemps, je veux dire, très, très longtemps !
Depuis le début des années 90, pour être précis.

Mais avant de rentrer dans les détails abortons la signification des termes `Contiuous Integration` en abrégé `CI`
et `Continuous Delivery`, `Continuous Deployement` ces deux termes en abrégés se traduisent par `CD`. 
Je sais ! C'est peut-être un peu flou pour toi, mais ces trois termes ne veulent pas dire la même.

Mais nous allons expliquer chaque terme un par un :smiley:


### 1.1 Continuous Integration
D'abord une définition, **l'intégration continue, c'est de merger le code écrit par les devs dans la source (GitHub, BitBucket, GitLab, etc.)
plusieurs fois par jour. En veillant qu'à chaque "commit" le code soit automatiquement builder et tester (testes unitaires, testes, intégration, etc.)
pour être sûr que le nouveau code ne cause pas de problèmes. Et si le code provoquent des bugs ou autres problèmes qu'ils soient détectés le plus tôt possible.
Tout ceci va permettre aux devs d'être immédiatement alertés si le code pose problème.**

Comme je le disais plus haut ! C'est au début des années 90 que l'intégration continue est apparue, bien qu'il ne s'appelait pas en encore comme cela.
Ce processus à été pour la première fois proposée par un certain Grady Booch en 1991 dans son livre [Object-oriented analysis and design with applications](https://www.goodreads.com/book/show/424923.Object_Oriented_Analysis_and_Design_with_Applications)`.
Son idée était d'utiliser plus souvent des classes et des objects de manière à simplifier la conception d'une application et bien sûr pouvoir l'intégrer fréquemment.

En 1997, est arrivé le concept de "[extreme programming](https://www.umsl.edu/~sauterv/analysis/f06Papers/Hutagalung/#:~:text=The%20origin%20of%20extreme%20programming,to%20be%20a%20successful%20method.)" qui s'inspiré du livre de Booch (ça y est, c'est mon gars sûr à la compote ! :smiley:)
pour promouvoir la livraison des applications plusieurs fois par jour. La notion de `releasing many times a days` que n'avait pas proposé Booch, était complètement nouveau.

A cette époque, `extreme programming` à changer le game !
Ohh est fait important l'`extreme programming` à cette époque n'est pas [la méthode agile](extreme programming) que nous connaissons actuellement.
Non ! cette époque l'`extreme programming`, était de prendre des concepts et paradigms déjà existant et de les appliquer à l'extrême tout simplement.
Cependant, cette application extrême, a donné naissance aux concepts de `shorter release cycles`, `code reviews`, `pair programming`, testes unitaires, etc.
Tous les concepts et méthodologies (scrum, kanban, etc.) qui sont nés après viennent de l'`extreme programming` avec pour seul but d'améliorer 
la qualité du code et rendre ce code disponible pour les utilisateurs rapidement.






## 2. La ressource
### 2.1. ...

Intégration continue : 

Délivrer en continu

Déployer en continu

### 2.2. ...

## 3. Points importants à retenir


## 4. Pour aller plus loin
Pas besoin pour l'instant
